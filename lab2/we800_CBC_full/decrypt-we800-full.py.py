from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
import math
import os


def calculate_entropy(data):
    """Calculate the Shannon entropy of a byte string."""
    if not data:
        return 0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy -= p_x * math.log2(p_x)
    return entropy


def decrypt_data(encrypted_data, key, iv):
    """Decrypt data using AES CBC mode."""
    aes = AES.new(key, AES.MODE_CBC, iv)
    decrypted_data = aes.decrypt(encrypted_data)
    return decrypted_data


def decrypt_file(file_name):
    """Decrypt an image file using the key with the lowest entropy, generated by PBKDF2."""
    password = input("Please enter the password: ")
    salt = b"abc"
    iv = b"a" * 16  # IV of 16 "a" characters

    with open(file_name, 'rb') as file:
        encrypted_data = file.read()
    # Check if data length is a multiple of 16, pad if necessary
    if len(encrypted_data) % 16 != 0:
        needed_padding = 16 - len(encrypted_data) % 16
        encrypted_data += b"\x00" * needed_padding

    # Generate key using PBKDF2
    key = PBKDF2(password, salt, dkLen=32)  # Assuming AES-256 for dkLen=32

    decrypted_data = decrypt_data(encrypted_data, key, iv)
    entropy = calculate_entropy(decrypted_data)

    # Write decrypted data to a file
    with open(f"decrypted_{os.path.basename(file_name)}", "wb") as out_file:
        out_file.write(decrypted_data)
    print(
        f"Decrypted using PBKDF2 key with entropy {entropy:.4f}. Output saved as 'decrypted_{os.path.basename(file_name)}'.")


if __name__ == "__main__":
    decrypt_file("./we800_CBC_encrypted_full.bmp")
